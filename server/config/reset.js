import dotenv from 'dotenv'
import { pool } from './database.js';
dotenv.config({ path: new URL('../.env', import.meta.url).pathname });
import events from '../data/eventsData.js';
import locations from '../data/locationsData.js';

async function createTables(client) {
  const sql = `
    -- Drop in FK order
    DROP TABLE IF EXISTS events;
    DROP TABLE IF EXISTS locations;

    -- Integer IDs only
    CREATE TABLE locations (
      id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name         TEXT NOT NULL UNIQUE,
      description  TEXT,
      lat          DOUBLE PRECISION,
      lng          DOUBLE PRECISION,
      difficulty   TEXT,
      tags         TEXT[] DEFAULT '{}',
      img          TEXT
    );

    CREATE TABLE events (
      id             TEXT PRIMARY KEY,
      location_id    INTEGER NOT NULL REFERENCES locations(id) ON DELETE CASCADE,
      title          TEXT NOT NULL,
      starts_at      TIMESTAMPTZ NOT NULL,
      ends_at        TIMESTAMPTZ NOT NULL,
      tags           TEXT[] DEFAULT '{}',
      max_party_size INT,
      organizer      TEXT,
      price          NUMERIC(10,2) DEFAULT 0,
      description    TEXT,
      link           TEXT,
      created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
      updated_at     TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    CREATE INDEX IF NOT EXISTS idx_events_location ON events(location_id);
    CREATE INDEX IF NOT EXISTS idx_events_time ON events(starts_at, ends_at);
  `;
  await client.query(sql);
  console.log('‚úÖ Tables created');
}

async function seed(client) {
    await createTables(client);
  // 1) Insert locations, remember numeric ids
  const insertLoc = `
    INSERT INTO locations (name, description, lat, lng, difficulty, tags, img)
    VALUES ($1,$2,$3,$4,$5,$6,$7)
    RETURNING id, name;
  `;
  const locIdByKey = new Map(); // key = slug/id string from your data OR name

  for (const loc of locations) {
  const { rows } = await client.query(insertLoc, [
      loc.name,
      loc.description ?? null,
      loc.lat ?? null,
      loc.lng ?? null,
      loc.difficulty ?? null,
      Array.isArray(loc.tags) ? loc.tags : [],
      loc.img ?? null,
    ]);
    const row = rows[0];
    // Use your mock's identifier (e.g., "mossy-cavern") to map ‚Üí numeric id
    const key = String(loc.id ?? loc.slug ?? loc.name).toLowerCase();
    locIdByKey.set(key, row.id);
    // Also allow lookup by name
    locIdByKey.set(String(row.name).toLowerCase(), row.id);
  }
  console.log('üå≤ Locations seeded');

  // 2) Insert events, resolving location_id from slug/name
  const insertEvt = `
    INSERT INTO events
      (id, location_id, title, starts_at, ends_at, tags, max_party_size, organizer, price, description, link)
    VALUES
      ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
    ON CONFLICT (id) DO NOTHING;
  `;

  for (const e of events) {
  const locKeyRaw =
      e.locationId ?? e.location_id ?? e.location ?? e.locationName;
    const locKey =
      typeof locKeyRaw === 'string' ? locKeyRaw.toLowerCase() : String(locKeyRaw);
    const locationId = Number.isInteger(locKeyRaw)
      ? locKeyRaw
      : locIdByKey.get(locKey);

    if (!Number.isInteger(locationId)) {
      console.warn(`‚ö†Ô∏è  Skipping event (unknown location): ${e.title}`);
      continue;
    }

    await client.query(insertEvt, [
      e.id,
      locationId,
      e.title,
      e.starts_at ?? e.startsAt,
      e.ends_at ?? e.endsAt,
      Array.isArray(e.tags) ? e.tags : [],
      e.max_party_size ?? e.maxPartySize ?? null,
      e.organizer ?? null,
      e.price ?? 0,
      e.description ?? null,
      e.link ?? null,
    ]);
  }
  console.log('üó∫Ô∏è  Events seeded');
}

async function run() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await createTables(client);
    await seed(client);
    await client.query('COMMIT');
    console.log('üå± Seed complete');
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('‚ùå Seed failed:', err.message);
    process.exit(1);
  } finally {
    client.release();
    await pool.end();
  }
}

run();